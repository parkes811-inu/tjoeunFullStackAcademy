------ 2024-02-21
------ 14일차 수업 내용

1. 제네릭 타입 범위 제한
 : 제네릭 타입 범위 제한(Generics Type Bounds)은 
   제네릭 클래스나 메서드에서 허용되는 타입의 범위를 제한하는 기능 
   이를 통해 제네릭 타입을 사용할 때 특정한 종류의 타입만을 허용하도록 제한할 수 있음 
   이는 코드의 안정성과 타입 안정성을 높이는 데 도움이 됨.

• 타입 안정성 보장 : 특정한 종류의 타입만을 허용하므로, 잘못된 타입이 사용되는 것을 방지 
  				 이로 인해 컴파일 시점에서 타입 체크를 수행하여 런타임 에러 방지

• 코드 재사용성 향상 : 특정한 종류의 타입으로 제한하면 해당 타입에 대한 특정한 동작 또는 
 				  기능을 구현할 수 있는 제네릭 클래스나 메서드를 작성 가능 
 				  이를 통해 코드의 재사용성과 유지보수성이 향상
  				  
<T extends 상위타입>

• 제네릭 클래스의 타입 제한 
: 상위 경계 (Upper Bound)를 사용하여 제한할 수 있음 
  상위 경계 (Upper Bound) : extends 키워드를 사용하여 상위 클래스나 인터페이스를 제한 
  상위 경계를 설정하면 해당 클래스 또는 인터페이스와 그 자손 클래스들만이 타입 인자로 사용 

접근지정자 class 클래스명 <T extends 상위클래스> {

...

}

• 제네릭 메소드의 타입 제한
: 제네릭 메서드의 타입 제한은 메서드에 전달되는 타입 인자의 범위를 제한하는 방법.
  이를 통해 특정한 타입 또는 그 타입의 상위 또는 하위 타입만을 인자로 받을 수 있도록 제한 가능
  접근지정자<T extends 상위클래스명>T 메서드이름 (T t) {/ 부모 클래스의 메서드 사용 가능 /}
  (인터페이스로 작성되었음에도 implements를 사용하지 않음.)
  일반 메서드인데 매개변수로서 제네릭을 사용할 때의 제네릭 클래스 타입제한
  메서드의 매개변수로 제네릭 클래스 객체가 오는 경우의 타입제한

접근지정자 <T extends 상위클래스> T 메소드명(T t) {

...

}
 
• 제네릭 클래스 상속
- 부모 클래스(제네릭) -> 자식 클래스(제네릭)
: 상속 받은 자식클래스 또한 제네릭 클래스가 된다.
  부모의 제네릭 타입매개 변수를 그대로 물려받는다.

----------------------------------------------------------------------

2. Collection
: 개수가 변하는 객체 요소의 모음
 객체 요소를 다루는 동적 자료구조
 요소를 추가 및 삭제 가능
 요소의 개수에 따라 크기를 자동 조절

- 배열과 컬렉션의 차이점
• 배열								컬렉션
 - 정적 자료구조					동적 자료구조
 - 요소의 개수가 불변				요소의 개수가 가변 (추가/삭제 가능)
 - 사용가능한 요소				사용가능한 요소				
 –> 기본타입 O, 참조타입 O			-> 기본타입 X, 참조타입 O
								※ Wrapper 클래스로 기본타입 대체 사용

3. Collection Framework
: 데이터를 저장하고 처리하는 자료구조와 알고리즘을 표준화된 방법으로 제공하는 클래스 모음

▶ 컬렉션의 장점
 자료구조 및 알고리즘을 직접 구현 해야하는 시간과 노력을 덜어줍니다.
 높은 성능의 알고리즘 구현을 통해 성능을 높여줍니다.
 프로그램 개발 생산성을 향상시켜줍니다.

4. 컬렉션 - 주요 인터페이스 / 클래스
- 인터페이스 				내용 						컬렉션 클래스
• List<E> 	:	순서 있음, 데이터 중복 가능			ArrayList
												LinkedList
												Vector <- Stack
• Set<E> 	:	순서 없음, 데이터 중복 불가 			HashSet
												TreeSet
• Queue<E> 	: 큐 자료구조(선입선출)로 데이터를 관리		LinkedList
												ArrayDeque
												PriorityQueue
• Map<K, V> : 순서 없음, 키(key)와 값(value)		HashMap 
			  을 쌍으로 요소를 관리					TreeMap
			  key 는 중복 불가, value 는 중복 가능	

- 컬렉션 객체 선언 및 생성
• Vector<String> vector = new Vector<String>( );
• List<String> vector = new Vector<String>( );
* List 인터페이스를 구현한 클래스이면, List 타입으로 선언가능

- List 인터페이스
 : 요소를 순서대로 나열하여 저장
   요소를 index 로 관리
   index 를 이용하여 요소를 추가/검색/삭제 가능
 * 순서가 있고, 중복이 가능하다.  
 
----------------------------------------------------------------------

5. Vector
: index 로 요소를 접근하는 배열구조를 가변 크기로 다루는 컬렉션

• 주요 변수
elementCount : 요소의 개수
capacityIncrement : 증분 개수
					* 용량 초과 시, 증가시킬 개수

- 기본 생성 시, 요소를 10개 용량으로 생성
- 용량을 초과하여 요소 추가하면, 용량을 2배씩 증가시킴
(* 11번째 요소 추가시 용량을 10개에서 20개로 늘림)
- 중복 요소는 같은 레퍼런스를 가지고 있다
- 멀티 쓰레드 환경에서 요소를 동기화 처리한다

- 생성자 							설명
• Vector() 					  : 초기 용량을 10으로하여 Vector 객체를 생성
• Vector(Collection c) 		  : 지정한 컬렉션의 요소로 Vector 객체를 생성
• Vector(int initialCapacity) : 초기 용량을 지정하여 Vector 객체를 생성
• Vector(int initialCapacity, : 초기 용량, 증분 개수를 지정하여 Vector 객체를 생성  
int capacityIncrement) 

• Vector<String> v1 = new Vector<String>( ); 		초기 용량 : 10, 증분 : 2배씩
• Vector<String> v2 = new Vector<String>( v1 ); 	v1 요소로 초기화 하여 생성
• Vector<String> v3 = new Vector<String>( 20 ); 	초기 용량 : 20, 증분 : 2배씩
• Vector<String> v4 = new Vector<String>( 5, 5 ); 	초기 용량 : 5, 증분 : 5개씩

----------------------------------------------------------------------

6. Vector vs ArrayList
- Vector 와 ArrayList 는 내부적으로 동일한 구조
- 멀티 스레드 환경에서 데이터 동기화 여부 차이만 있다

• Vector						• ArrayList
 멀티스레드 환경에서 데이터를 동기화  멀티스레드 환경에서 데이터 동기화 X
 Thread Safe (안전) 			   Thread Unsafe

- Vector, ArrayList – 요소 추가
: 객체.add( 값 );

- Vector, ArrayList – 요소 삭제
: 객체.remove( 값 );

----------------------------------------------------------------------

7. LinkedList
: 연결리스트 자료구조를 다루는 컬렉션
인접한 요소끼리 서로 참조하고 있는 이중 연결 리스트의 구조로 되어있다
다른 List 인터페이스의 컬렉션과 사용방법은 동일하다

- LinkedList – 요소 추가/삭제
 : 요소를 추가할 때, 기존 연결을 끊고 새로운 요소에 연결해주면 됨
 요소를 삭제할 때, 제거될 요소와의 연결을 끊고 앞뒤로 연결해주면 됨

----------------------------------------------------------------------

8. Set 인터페이스
: 요소의 저장 순서를 보장하지 않음
요소를 중복하여 저장할 수 없음
null 도 하나만 저장 가능
요소의 값 자체로 추가/삭제
* 순서가 없고, 중복이 불가능하다.

• HashSet
: 중복되지 않는 요소를 다루는 컬렉션
  해시코드 그리고 객체를 비교하여, 동일한 요소는 저장하지 않는다.
  index 가 없기 때문에 get( ) 메소드가 없다
* 문자열의 경우, String 클래스가 같은 문자열은 같은 해시코드로
  저장하기 때문에 다른 객체라도, 내용이 같은 문자열은 저장되지 않는다.

 ----------------------------------------------------------------------
 
 9. Map 인터페이스
: 키와 값으로 구성된 Entry 객체를 요소로 저장하는 구조
  키는 중복 불가, 값은 중복 가능
* 순서가 없고, 값은 중복이 가능하나, 키는 중복이 불가능하다.

• HashMap
: 중복되지 않는 키(key) 와 값(value) 을 한 쌍으로 요소를 관리하는 컬렉션
동일한 key 인 경우, 마지막에 추가한 value 로 변경된다.
put( 키, 값 ) 형태의 메소드로 요소를 추가한다.
 